# Реализация (Технологии программирования)

Кто за что отвечает: 
===================
**Евдокимов Егор** - правила игры, управление Units, ConsoleDispatcher, Controller, выполняющий все команды от диспетчера в данных игры, связка команд игрока и действий над объектами в основном цикле, UML диаграммы, картинки в PyGCell и PyGUnit, классы Object и Group, toolbar, класс Player. 

**Кудрявцев Иван** - создание и управление ячейками поля (cell), их UML диаграмму, общую архитектуру проекта, хранение игровой информации, консольный и pygame-овский вывод поля, связь графики и "backend" части, классы PyGCells, PyGUnits, PyGameDisplay, PyGameDispatcher, Button, PyGButtons, Command.

Архитектура и почему все именно так:
==============================
Реализован класс Game, в методах которого прописан основной игровой цикл, начало/конец из игры. В этом же классе хранится игровая информация(Data) о расположении cell’ов и unit'ов, controller.
Также в Game храним поле dispatcher и display, которые отвечают за прием команд от играющего и вывод игрового поля на экран, они наследуются от абстракного класса Dispatcher и Display, чтобы была возможность перейти на консольную/pygame графику и pygame/console диспетчер.


Порождающие паттерны (для 1 чекпоинта)
--------------------
Создание юнитов. Реализован паттерн **_фабрика_** для юнитов. 
Так как с помощью этого паттерна можно задавать общий интерфейс для объектов(методы action, say), но чтобы конкретные оъекты имели собственно реализованные методы
как нападение(как у воинов), или сбор монет(у шахтеров). Таким образом мы отделили код производства продктов от остального кода и оставили возможность расширять игру(доавблять новые типы воинов), не изменяя основу.
Конструктор каждого поля - его создание от каких-то параметров(рельефа), который на нем находиться.

Структурные паттерны (для 2 чекпоинта)
--------------------
Для отображения игры используется библиотека pygame, использован паттерн ***декоратор_**(такая полезная обертка) для использования и расширения базовых классов Unit и Cell - PugUnit и PygCell. 
Оба имеют одинаковый функционал и наравне с кнопками Button наследуются от класса Object(наследующегося от sprite.Sprite). 

Так же был добавлен класс Group(наследующийся от sprite.Group) для, например, отрисовки всех PygUnit и PygCell разом. Все это отображено на новой подробной UML-диаграмме.

Так же был создан класс Display(абстрация, вместо которой можно подставлять либо PyGameDisplay, либо ConsoleDisplay) и Dispatcher(соответственно PyGameDisplay и ConsoleDisplay) для успешного взаимодействия с классом Controller. 
По сути, мы разделили абстракцию и реализацию. Оставив возможность расширения системы.
С такой структурой легко добавить новый способ отрисовки, например, в браузере, не изменяя внутренний механизм работы. Таким образом был реализован паттерн **_мост_**.


Поведенческие паттерны (для 3 чекпоинта)
--------------------
Игрок может создавать юнитов на своей территории(create), перемещать войска(move), нападать на соперника(attack), улучшать своих юнитов(upgrade).

Для третьей части были релизован паттерн **_команда_**, для взаимодействия Dispatcher(отлавливающего любые действия игроков) с Controller, класса, который управляет процессом игры, изменяя данные игроков(их армии юнитов и счет).
Это удобно так как для разных команд требуется банально разное количество координат, например, для upgrade всего 2, а для attack - 4. 
Класс Command помог наладить логирование, сейчас все важные действия логируются и выводятся в консоль.
Сам Contoller по факту является паттерном **_посредник_**, он уменьшает связность классов Data и всех pygame объектов. Благодаря Controller, если игрок наводится на кнопку, класс display отрисовывает полунажатую кнопку, если
игрок нажимает на юнита, рисуется рамка, а при формировании прваильной комманды происходит ход и изменяются данные игроков.

UML diagram:
=============================
![UML diagram](MinersArchersUML.png)
