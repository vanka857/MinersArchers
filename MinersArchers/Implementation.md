# Реализация (Технологии программирования)

Кто за что отвечает 
===================
**Евдокимов Егор** - правила игры, управление Units, ConsoleDispatcher, Controller, выполняющий все команды от диспетчера в данных игры, связка команд игрока и действий над объектами в основном цикле, UML диаграммы, картинки в PyGCell и PyGUnit, классы Object и Group, toolbar, класс Player. 

**Кудрявцев Иван** - создание и управление ячейками поля (cell), их UML диаграмму, общую архитектуру проекта, хранение игровой информации, консольный и pygame-овский вывод поля, связь графики и "backend" части, классы PyGCells, PyGUnits, PyGameDisplay, PyGameDispatcher, Button, PyGButtons, Command.

Архитектура и почему все именно так:
==============================
Реализован класс Game, в методах которого прописан основной игровой цикл, начало/конец из игры. В этом же классе хранится игровая информация(Data) о расположении cell’ов и unit'ов, controller.
Также в Game храним поле dispatcher и display, которые отвечают за прием команд от играющего и вывод игрового поля на экран, они наследуются от абстракного класса Dispatcher и Display, чтобы была возможность перейти на консольную/pygame графику и pygame/console диспетчер.

## 1 чекпоинт
###Порождающие паттерны:

Создание юнитов. Реализован паттерн **_фабрика_** для юнитов. 
Так как с помощью этого паттерна можно задавать общий интерфейс для объектов(методы action, say), но чтобы конкретные оъекты имели собственно реализованные методы
как нападение(как у воинов), или сбор монет(у шахтеров). Таким образом мы отделили код производства продктов от остального кода и оставили возможность расширять игру(доавблять новые типы воинов), не изменяя основу.
Конструктор каждого поля - его создание от каких-то параметров(рельефа), который на нем находиться.

## 2 чекпоинт
###Структурные паттерны: 

Для отображения игры используется библиотека pygame, использован паттерн **_декоратор_**(такая полезная обертка) для использования и расширения базовых классов Unit и Cell - PugUnit и PygCell. 
Оба имеют одинаковый функционал и наравне с кнопками Button наследуются от класса Object(наследующегося от sprite.Sprite). 

Так же был добавлен класс Group(наследующийся от sprite.Group) для, например, отрисовки всех PygUnit и PygCell разом. Все это отображено на новой подробной UML-диаграмме.

Так же был создан класс Display(абстрация, вместо которой можно подставлять либо PyGameDisplay, либо ConsoleDisplay) и Dispatcher(соответственно PyGameDisplay и ConsoleDisplay) для успешного взаимодействия с классом Controller. 
По сути, мы разделили абстракцию и реализацию. Оставив возможность расширения системы.
С такой структурой легко добавить новый способ отрисовки, например, в браузере, не изменяя внутренний механизм работы. Таким образом был реализован паттерн **_мост_**.

## 3 чекпоинт
###Поведенческие паттерны:

Игрок может создавать юнитов на своей территории(create), перемещать войска(move), нападать на соперника(attack), 
улучшать своих юнитов(upgrade).

Для третьей части были релизован паттерн **_команда_** (класс Command), 
для _создания_ и _обработки_ команд в Controller, классе, который управляет процессом 
игры, изменяя данные игроков(их армии юнитов и счет).

Это удобно, так как для разных команд требуется банально разное количество координат.
Например, для upgrade всего 2, 
а для attack - 4. 

Сейчас все важные действия (в первую очередь, команды) _логируются_ и выводятся в консоль. Для **логирования** был написан класс Logs

Сам Contoller по факту реализует паттерн **_посредник_**, он уменьшает связность классов Data и всех pygame объектов. 
Благодаря Controller, если игрок наводится на кнопку, класс display отрисовывает полунажатую кнопку, если
игрок нажимает на юнита, рисуется рамка, а при формировании прваильной комманды происходит ход и изменяются данные игроков.

###Дистрибутив
####Запуск:
1. Перейти в директорию MinersArchers/dist
2. Запустить MinersArchers (executable) 

####Создание:
* Для создания дистрибутива был использовн модуль **PyInstaller**. 
* Дистрибутив создается в **однофайловой** конфигурации (то есть почти _все, что нужно собирается в executable-файл_).
* Для более точной настройки создания дистрибутива был использован специальный файл конфигурации **Main.spec** (поддерживается PyInstaller).
* **Файлы конфигурации копируются** в директорию с дистрибутивом (в поддиректорию static/config)

Таким образом, при запуске executable-файла, ресурсы (static/res) подгружаются во временную папку, определяемую PyInstaller, а файлы конфигурации копируются

###Файлы конфигурации запуска:
* Есть два файла конфигурации: **field.json** и **players.json**
* Расположены в _static/config_
* В них пожно настраивать **параметры поля** и **данные игроков**

UML diagram:
=============================
![UML diagram](MinersArchersUML.png)
